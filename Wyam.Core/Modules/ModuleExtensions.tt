<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.IO" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Text.Encoding" #>
<#@ assembly name="System.Threading.Tasks" #>
<#@ assembly name="$(SolutionDir)packages\Microsoft.CodeAnalysis.Common.1.0.0-rc1\lib\net45\Microsoft.CodeAnalysis.dll" #>
<#@ assembly name="$(SolutionDir)packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc1\lib\net45\Microsoft.CodeAnalysis.CSharp.dll" #>
<#@ assembly name="$(SolutionDir)packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.CodeAnalysis" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
<#@ output extension=".cs" #>
using System;
using System.Collections.Generic;
using System.IO;

<# Process(); #>
<#+
	public void Process()
	{
		// Get a SyntaxTree for every file
		foreach(CSharpSyntaxTree syntaxTree in Directory.EnumerateFiles(Path.GetDirectoryName(Host.TemplateFile))
			.Where(x => Path.GetExtension(x) == ".cs")
			.Select(x => CSharpSyntaxTree.ParseText(File.ReadAllText(x)))
			.Cast<CSharpSyntaxTree>())
		{
			// Get all class declarations in each file that derive from Module
			foreach(ClassDeclarationSyntax classDeclaration in syntaxTree.GetRoot()
				.DescendantNodes()
				.OfType<ClassDeclarationSyntax>()
				.Where(x => x.BaseList != null && x.BaseList.Types
					.Any(y => y.Type is Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax 
						&& ((Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)y.Type).Identifier.Text == "Module")))
			{
				// Output the namespace
				SyntaxNode namespaceNode = classDeclaration.Parent;
				while(namespaceNode != null && !(namespaceNode is NamespaceDeclarationSyntax))
				{
					namespaceNode = namespaceNode.Parent;
				}
				if(namespaceNode != null)
				{
					WriteLine("namespace " + ((NamespaceDeclarationSyntax)namespaceNode).Name.ToString() + Environment.NewLine + "{");
				}
			
				// Output the extensions class
				WriteLine("    public static class " + classDeclaration.Identifier.Text + "PipelineExtensions" + Environment.NewLine + "    {");
			
				// Get all non-static public constructors
				foreach(ConstructorDeclarationSyntax constructor in classDeclaration.Members
					.OfType<ConstructorDeclarationSyntax>()
					.Where(x => x.Modifiers.Count == 1 && x.Modifiers[0].Text == "public"))
				{
					// Output the static constructor method
					WriteLine("        public static IPipeline " + classDeclaration.Identifier.Text + constructor.ParameterList.ToString().Insert(1, "this IPipeline pipeline, ") + Environment.NewLine + "        {");
				
					// Create and add the module
					WriteLine("            return pipeline.AddModule(new " + classDeclaration.Identifier.Text + "(" + string.Join(", ", constructor.ParameterList.Parameters.Select(x => x.Identifier.Text)) + "));");
				
					// Close method
					WriteLine("        }");
				}
			
				// Close extensions class
				WriteLine("    }");			
			
				// Close namespace
				if(namespaceNode != null)
				{
					WriteLine("}");
				}
			}
		}
	}
#>

